{ %section1_4
	\subsection{Методы синхронизации в параллельных программах}
	\parВ параллельных программах разработчик часто сталкивается с проблемой синхронизации между потоками. Как правило, проблемы возникают при доступе к памяти и одновременном выполнении каких-то критических участков кода - критических секций.
	\par\textbf{Критической областью} называют секцию программы, которая должна выполняться с исключительным правом доступа к разделяемым данным, на которые имеются ссылки в этой программе. Процесс, готовящийся войти в критическую область, может быть задержан, если любой другой процесс в это время выполняется в подобной критической области.
	\parВ этом разделе будут подробно рассмотрены механизмы синхронизации потоков на программном уровне.
	\parСуществуют следующие методы решения проблем синхронизации потоков:
		\begin{itemize}
			\item\textbf{Атомарные операции} - операции, которые выполняются целиком или не выполняются вовсе. Например, транзакция к БД является атомарной операцией. Когда два потока пытаются инкрементировать одну и ту же ячейку памяти несинхронизированно, значение может увеличиться на 2, а может и на 1 в зависимости от поведения потоков, так как операция инкрементации представляет собой как минимум 3 ассемблерные инструкции. Чтобы избежать этого стоит объявлять тип данных атомарным (если таковой есть в данном языке программирования/библиотеке). Частным случаем атомарных операций являются read-modify-write, compare-and-swap, test-and-set, fetch-and-add. Подробнее проблема реализации атомарных операций будет поднята в разделе\\~\ref{atomic:section} \textit{Атомарность операций в многопоточной программе}.
			\item\textbf{Семафор} - объект, ограничивающий число потоков, которые могут войти в эту область кода. Как правило это число задается при инициализации семафора. Затем при захвате семафора потоком проверяется количество потоков, захвативших семафор. Если максимальное количество потоков достигнуто, то поток будет ждать пока какой-то из потоков, вошедших в область кода, освободит его. Часто использование семафоров неоправдано, так как накладные расзоды на создание и поддержку семафора большие. Также следует избегать ''утечки семафора'', ситуации при которой поток не выходит из семафора при окончании выполнения области кода если программист забыл освободить ресурс.
			\item\textbf{Reader/writer semaphore} предоставляет потокам права \textit{только} на чтение или запись, причем во время записи данных одним потоком остальные потоки не имеет доступа к ресурсу. Однако в таких семафорах может быть проблема \textit{ресурсного голодания (starvation)}, при котором пока потоки будут читать данные, другие потоки не смогут записать данные долгий промежуток времени или наоборот. Частным решением этой проблемы при равном приоритете потоков может быть поочередный доступ потоков в очереди к доступи и записи.
			\item\textbf{Мьютекс} - частный случай семафора, при котором данную область кода может захватывать только один поток. Часто используется при организации управления критическими секциями, так как ''легче'' классического семафора. Следует отметить, что в стандарте языка C++11 кроме стандартного мьютекса существуют разные его модификации:  \textit{recursive\textunderscore mutex} - мьютекс, допускающий повторные захваты участка кода этим же потоком, \textit{timed\textunderscore mutex} - мьютекс с таймером захвата и  \textit{recursive\textunderscore timed\textunderscore mutex}, совмещающий достоинства обеих версий.
			\item\textbf{Spinlock (циклическая блокировка)} - блокировка, при которой поток в цикле ожидает освобождения ресурса. Не всегда является оптимальным решением, так как ожидающий поток работает во время ожидания. Внутри секции кода необходимо избегать прерываний, чтобы избежать deadlock'a.
			\item\textbf{Seqlock (последовательная блокировка)} - механизм синхронизации, предназначенный для быстрой записи переменной несколькими потоками. В ядре Linux работает следующим образом: поток ждет, пока критическая секция освободится(spinlock); при входе в секцию инкрементируется счетчик, поток делает свою работу. При выходе из секции поток проверяет значение счетчика. Если значение счетчика не изменилось, значит в данный момент никто не записывал данные и поток завершает работу, иначе он считывает значение переменной заново.
			\item\textbf{Knuth–Bendix сompletion algorithm} - одним из решений проблем синхронизации является алгоритм Кнута-Бендикса из курса дискретной математики. С его помощью можно перейти от последовательной программы к каскадной. Однако не для всех программ этот лагоритм работает, иногда он может уйти в бесконечный цикл или завершиться с ошибкой.
			\item\textbf{Barier (барьер)} - участок кода, в котором синхронизируется состояние потоков. Например, если для функции в главном потоке требуется чтобы все дочерние потоки закончили свою работу, можно поставить барьер перед ней. Тогда она будет ждать завершения работы дочерних потоков, после чего все потоки продолжат свою работу. Пример реализации барьера может быть критическая секция, код которой разрешается выполняться только последнему потоку, запросившему выполнение. Остальные потоки должны ожидать его.
			\item\textbf{Неблокирующие алгоритмы.} Часто бывает полезно не использовать стандартные приемы блокировки, а сделать алгоритм неблокирующим. В таком случае программист должен самостоятельно гарантировать, что критические секции кода не будут выполняться одновременно и целостность разделяемой памяти. Также плюсом таких алгоритмов является безопасная обработка прерываний. Для реализации таких адгоритмов часто используются другие технологии синхронизации: read-modify-write, CAS (см. раздел~\ref{atomic:section}) и другие.
			\item\textbf{RCU (read-copy-update)} - алгоритм, позволяющий потокам эффективно считывать данные, оставляя обновление данных на конец работы алгоритма, гарантируя при этом релевантные данные. Только один поток может писать данные, но читать данные могут сразу несколько потоков. Достигается это путем атомарной подмены указателя (CAS). Старые версии данных хранятся для прошлых обращений, пока на них есть хотя бы один указатель.
		\end{itemize}
	\parНесмотря на большое количество методов синхронизации чаще всего надо исходить из решаемой задачи. Например, если мы хотим сделать общую целочисленную переменную для нескольких потоков, нет смысла создавать mutex или semaphore, более оптимально сделать переменную атомарной. Всегда надо учитывать накладные расходы на создание блокировок и время разработки.
}